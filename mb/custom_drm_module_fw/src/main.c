/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xparameters.h"
#include "xil_exception.h"
#include "xstatus.h"
#include "xaxidma.h"
#include "xil_mem.h"
#include "util.h"
#include "secrets.h"
#include "xintc.h"
#include "constants.h"
#include "sleep.h"

#include "HASH/sha256.h"
#include "AES/aes.h"
#include "RSA/rsa.h"
//#include "frankencrypt.c"

//For testing random
#include <stdlib.h>

//////////////////////// GLOBALS ////////////////////////


// audio DMA access
static XAxiDma sAxiDma;

// LED colors and controller
//u32 *led = (u32*) XPAR_RGB_PWM_0_PWM_AXI_BASEADDR;
//const struct color RED =    {0x01ff, 0x0000, 0x0000};
//const struct color YELLOW = {0x01ff, 0x01ff, 0x0000};
//const struct color GREEN =  {0x0000, 0x01ff, 0x0000};
//const struct color BLUE =   {0x0000, 0x0000, 0x01ff};

// shared buffer values
enum commands { QUERY_PLAYER, QUERY_SONG, LOGIN, LOGOUT, SHARE, PLAY, STOP, DIGITAL_OUT, PAUSE, RESTART, FF, RW };
enum states   { STOPPED, WORKING, PLAYING, PAUSED };

// change states
//#define change_state(state, color) c->drm_state = state; setLED(led, color);
//#define set_stopped() change_state(STOPPED, RED)
//#define set_working() change_state(WORKING, YELLOW)
//#define set_playing() change_state(PLAYING, GREEN)
//#define set_paused()  change_state(PAUSED, BLUE)
#define change_state(state) c->drm_state = state;
#define set_stopped() change_state(STOPPED)
#define set_working() change_state(WORKING)
#define set_playing() change_state(PLAYING)
#define set_paused()  change_state(PAUSED)

// shared command channel -- read/write for both PS and PL
volatile cmd_channel *c = (cmd_channel*)SHARED_DDR_BASE;

static const uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

// internal state store
internal_state s;

static u8 hash_buffer[SHA256_HASH_SZ]; //Used for storing the output of SHA256

static u8 user_key_block[HASH_SZ]; //Holds the user key while they are logged in

static u8 user_rsa_private_key_block[RSA_KEY_SZ]; //Holds the user private key while they are logged in

static u8 region_key_block[HASH_SZ]; //Holds common key after is_locked() is called

static u8 universal_buffer[sizeof(song_chunk)];

//////////////////////// INTERRUPT HANDLING ////////////////////////


// shared variable between main thread and interrupt processing thread
volatile static int InterruptProcessed = FALSE;
static XIntc InterruptController;

void myISR(void) {
    InterruptProcessed = TRUE;
}

//////////////////////// HELPER FUNCTIONS  ////////////////////////

//returns true if they are the same
int compare_hashes(u8 * hash1, u8 * hash2)
{
	int ret = 1;
	for( int i = 0; i < HASH_SZ; i++)
	{
		if( hash1[i] != hash2[i])
		{
			ret = 0;
		}
	}
	return ret;
}

int compare_verification_hashes(u8 * hash1, u8 * hash2)
{
	int ret = 1;
	for( int i = 0; i < HASH_SZ_VERIFY; i++)
	{
		if( hash1[i] != hash2[i])
		{
			ret = 0;
		}
	}
	return ret;
}

void sub(uint8_t * A, uint8_t * B, uint8_t * out)
{
	u16 carry = 1;
	for( int i = 127; i >= 0; i--){
		u16 a = A[i];
		u16 b = B[i];
		carry = a + ~b + carry;
		out[i] = carry % 0x100;
		carry >>= 8;
		carry = (carry % 2) ^ 1;
	}
}


//Signature verification must first be started
int verify_signature(u8 * expected, u8 * n)
{
	static u8 sig_out[RSA_KEY_SZ];

	rsa_get_verify_out(sig_out);


	int ret1 = 1;

	for(int i = 0; i < RSA_KEY_SZ ; i++){
		if(sig_out[i] != expected[i]){
			ret1 = 0;
		}
	}

	int ret2 = 1;
	for(int i = 0; i < RSA_KEY_SZ ; i++){
		if(sig_out[i] - n[i] != expected[i]){
			ret2 = 0;
		}
	}

	if(ret1 == 1){
		return 1;
	}else if( ret2 == 1){
		return 1;
	}else{
		return 0;
	}
}

//////////////////////// COMMAND FUNCTIONS ////////////////////////


// attempt to log in to the credentials in the shared buffer
void login() {
    if (s.logged_in) {
        mb_printf("Already logged in. Please log out first.\r\n");
    } else {
    	memcpy(s.username, (void*)c->username, USERNAME_SZ);
		memcpy(s.pin, (void*)c->pin, MAX_PIN_SZ);

		// Check string lengths
		size_t pin_length = strlen(s.pin);
		size_t username_length = strlen(s.username);
		if ((pin_length > MAX_PIN_SZ) || (username_length > USERNAME_SZ)){
			// reject login attempt
			mb_printf("Invalid input\r\n");
			memset((void*)c->username, 0, USERNAME_SZ);
			memset((void*)c->pin, 0, MAX_PIN_SZ);
			return;
		}

		struct AES_ctx ctx;

		//Start HASH computation
    	sha256_compute_hash((void*)s.pin, pin_length, 1, hash_buffer);

    	AES_init_ctx(&ctx, hash_buffer);


        for (int i = 0; i < NUM_PROVISIONED_USERS; i++) {
            // search for matching username
            if (!strcmp((void*)s.username, USERNAMES[PROVISIONED_UIDS[i]])) {
                // check if pin matches
            	memcpy(user_key_block, PROVISIONED_USER_KEY_BLOCKS[i], HASH_SZ);

            	AES_ECB_decrypt(&ctx, user_key_block); //Decrypt the block. Should now be equal to device hash

            	if ( compare_hashes((void*)user_key_block, (void*)DEVICE_HASH) ){
            		//update states
            		s.logged_in = 1;
                    c->login_status = 1;
                    s.uid = PROVISIONED_UIDS[i];
                    mb_printf("Logged in for user '%s'\r\n", c->username);
                    memcpy(user_key_block, hash_buffer, HASH_SZ); // Copy user key into user_key_block

                    //Decrypt private key
                    memcpy(user_rsa_private_key_block, PROVISIONED_USER_PRIVATE_KEY_D_BLOCKS[s.uid], RSA_KEY_SZ);
                    AES_init_ctx_iv(&ctx, user_key_block, iv);
                    AES_CBC_decrypt_buffer(&ctx, user_rsa_private_key_block, RSA_KEY_SZ);
                    return;
            	} else {
                    // reject login attempt
                    mb_printf("Incorrect pin for user '%s'\r\n", c->username);
                    memset((void*)c->username, 0, USERNAME_SZ);
                    memset((void*)c->pin, 0, MAX_PIN_SZ);
                    memset((void*)s.username, 0, USERNAME_SZ);
					memset((void*)s.pin, 0, MAX_PIN_SZ);
                    return;
                }
            }
        }

        // reject login attempt
        mb_printf("User not found\r\n");
        memset((void*)c->username, 0, USERNAME_SZ);
        memset((void*)c->pin, 0, MAX_PIN_SZ);
    }
}

// attempt to log out
void logout() {
    if (s.logged_in) {
        mb_printf("Logging out...\r\n");
        s.logged_in = 0;
        c->login_status = 0;
        memset((void*)c->username, 0, USERNAME_SZ);
        memset((void*)c->pin, 0, MAX_PIN_SZ);
        memset((void*)user_key_block, 0,HASH_SZ); //Delete user key
        memset((void*)user_rsa_private_key_block, 0,  RSA_KEY_SZ); //Delete use private key
        memset((void*)hash_buffer, 0, SHA256_HASH_SZ);
        s.uid = 0;
    } else {
        mb_printf("Not logged in\r\n");
    }
}

void query_player() {
    c->query.num_regions = NUM_PROVISIONED_REGIONS;
    c->query.num_users = NUM_PROVISIONED_USERS;

    for (int i = 0; i < NUM_PROVISIONED_REGIONS; i++) {
        strcpy((char *)q_region_lookup(c->query, i), REGION_NAMES[PROVISIONED_RIDS[i]]);
    }

    for (int i = 0; i < NUM_PROVISIONED_USERS; i++) {
        strcpy((char *)q_user_lookup(c->query, i), USERNAMES[i]);
    }

    mb_printf("Queried player (%d regions, %d users)\r\n", c->query.num_regions, c->query.num_users);
}

// loads the song metadata in the shared buffer into the local struct
void load_song_md() {
	memcpy((void *)&s.song_md, (void *)&c->song.song_header, sizeof(header));
	memcpy((void *)&s.song_shared_user_md, (void *)&c->song.shared_user_block, sizeof(shared_users));
}

int verify_song_md_hash()
{
	sha256_compute_hash((void*)&s.song_md, sizeof(header)-HASH_SZ-RSA_KEY_SZ, 1, hash_buffer);
	return compare_hashes(hash_buffer, s.song_md.header_hash);
}

int verify_song_hash_signature( uint8_t * hash, uint8_t * signature , uint8_t * key, uint8_t * n)
{

	static u8 sig_out[RSA_KEY_SZ];

	uint8_t * expected = (void*)hash;

	rsa_get_verify_out(sig_out);

	int ret1 = 1;

	for(int i = 0; i < RSA_KEY_SZ - HASH_SZ ; i++){
		if(sig_out[i] != 0){
			ret1 = 0;
			break;
		}
	}
	for(int i = 0; i < HASH_SZ ; i++){
		if(sig_out[i + (RSA_KEY_SZ - HASH_SZ)] != expected[i]){
			ret1 = 0;
			break;
		}
	}

	return ret1;
}


int verify_song_md_hash_signature()
{
	//TODO Implement. Must be blocking operation because AES cannot be used with RSA simultaneously


	mb_printf("Sig \r\n");
//	for (int i = 0; i < 128; i++)
//	{
//		mb_printf("%02x \n\r", s.song_md.hash_signature[i]);
//	}
	static u8 sig_out[RSA_KEY_SZ];

	uint8_t * expected = (void*)s.song_md.header_hash;

//	rsa_begin_verify( (void*)s.song_md.hash_signature, (void*)GLOBAL_PUBLIC_E, (void*)GLOBAL_PUBLIC_N);
//	rsa_get_verify_out(sig_out);
	rsa_encrypt( (void*)s.song_md.hash_signature, (void*)GLOBAL_PUBLIC_E, (void*)GLOBAL_PUBLIC_N,  sig_out);



//	mb_printf("After \r\n");
//	for (int i = 0; i < 128; i++)
//	{
//		mb_printf("%02x \n\r", sig_out[i]);
//	}

	if(sig_out[0] != 0){

		sub(sig_out,(void*)GLOBAL_PUBLIC_N,sig_out);
//		mb_printf("After \r\n");
//		for (int i = 0; i < 128; i++)
//		{
//			mb_printf("%02x \n\r", sig_out[i]);
//		}
	}

	int ret1 = 1;

	for(int i = 0; i < RSA_KEY_SZ - HASH_SZ ; i++){
		if(sig_out[i] != 0){
			ret1 = 0;
			break;
		}
	}
	for(int i = 0; i < HASH_SZ ; i++){
		if(sig_out[i + (RSA_KEY_SZ - HASH_SZ)] != expected[i]){
			ret1 = 0;
			break;
		}
	}

	return ret1;
}

void print_song_metadata()
{
	mb_printf("Owner %d\n\r",s.song_md.owner_id);
	mb_printf("Song size %d\n\r", s.song_md.song_size);
	mb_printf("Song Hash[0] %02x \n\r",s.song_md.song_hash[0]);
	mb_printf("Song Verify Hash[0] %02x \n\r",s.song_md.song_verify_hash[0]);
	mb_printf("Song header_hash[0] %02x \n\r",s.song_md.header_hash[0]);
	mb_printf("Song hash_signature[0] %02x \n\r",s.song_md.hash_signature[0]);
}

// load_song_md() should be called first
// if the song is region enabled this function decrypts the common_key and loads it into region_key_block[]
int is_region_locked(){
	int region_locked = TRUE; // reset lock for region check
	int enabled_region_bits = s.song_md.enabled_regions.regions;
	for (int j = 0; j < (u8)NUM_PROVISIONED_REGIONS; j++) {
		if ((enabled_region_bits >> PROVISIONED_RIDS[j]) & 1 ){
			//Load region key block from song into region_key_block buffer
			int region_key_offset = HASH_SZ * PROVISIONED_RIDS[j];
			memcpy((void*)region_key_block, (s.song_md.enabled_regions.region_keys + region_key_offset) , HASH_SZ );
			//Decrypt region_key_block using region key from secrets.h

			struct AES_ctx ctx;
			AES_init_ctx(&ctx, REGION_KEYS[PROVISIONED_RIDS[j]]); //init AES key
			AES_ECB_decrypt(&ctx, region_key_block); //Decrypt the block. Should now be equal to common_key

			region_locked = FALSE;
			break;
		}
	}
	return region_locked;
}

// checks if the song loaded into the shared buffer is locked for the current user
// load_song_md() should be called first
// if the song is region enabled this function decrypts the common_key and loads it into region_key_block[]
int is_locked() {
    int user_locked = TRUE;
    int region_locked = TRUE;

    // check for authorized user
    if (!s.logged_in) {
        mb_printf("No user logged in");
    } else {
        //load_song_md();

        // check if user is authorized to play song
        if (s.uid == s.song_md.owner_id) {
        	user_locked = FALSE;
        } else {

        	//TODO Implement song sharing
        	uint64_t shared_mask = 1 << s.uid;
        	if( (c->song.shared_user_block.enabled_users & shared_mask) > 0){
        		//User may be allowed to play this song
        		//TODO decrypt concat song_key
        		rsa_encrypt(c->song.shared_user_block.user_key_blocks[s.uid], (void*)user_rsa_private_key_block, PROVISIONED_USER_PUBLIC_KEY_N_BLOCKS[s.uid],  universal_buffer);
        		//TODO copy concat song_key from universal buffer to somewhere else
        	}
//            for (int i = 0; i < NUM_PROVISIONED_USERS && locked; i++) {
//                if (s.uid == s.song_md.uids[i]) {
//                    locked = FALSE;
//                }
//            }
        }

        if (user_locked) {
            mb_printf("User '%s' does not have access to this song", s.username);
            return user_locked;
        }
        mb_printf("User '%s' has access to this song", s.username);

        region_locked = is_region_locked(); // This loads the common key into the region_key_block

        if (!region_locked) {
            mb_printf("Region Match. Full Song can be played. Unlocking...");
        } else {
            mb_printf("Invalid region");
        }
    }
    return region_locked;
}

// returns whether a uid has been provisioned
int is_provisioned_uid(char uid) {
    for (int i = 0; i < NUM_PROVISIONED_USERS; i++) {
        if (uid == PROVISIONED_UIDS[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

// looks up the username corresponding to the uid
int uid_to_username(char uid, char **username, int provisioned_only) {
    for (int i = 0; i < NUM_USERS; i++) {
        if (uid == USER_IDS[i] &&
            (!provisioned_only || is_provisioned_uid(uid))) {
            *username = (char *)USERNAMES[i];
            return TRUE;
        }
    }
    mb_printf("Could not find uid '%d'\r\n", uid);
    *username = "<unknown user>";
    return FALSE;
}

// looks up the uid corresponding to the username
int username_to_uid(char *username, char *uid, int provisioned_only) {
    for (int i = 0; i < NUM_USERS; i++) {
        if (!strcmp(username, USERNAMES[USER_IDS[i]]) &&
            (!provisioned_only || is_provisioned_uid(USER_IDS[i]))) {
            *uid = USER_IDS[i];
            return TRUE;
        }
    }

    mb_printf("Could not find username '%s'\r\n", username);
    *uid = -1;
    return FALSE;
}

// returns whether an rid has been provisioned
int is_provisioned_rid(char rid) {
    for (int i = 0; i < NUM_PROVISIONED_REGIONS; i++) {
        if (rid == PROVISIONED_RIDS[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

// looks up the region name corresponding to the rid
int rid_to_region_name(char rid, char **region_name, int provisioned_only) {
    for (int i = 0; i < NUM_REGIONS; i++) {
        if (rid == REGION_IDS[i] &&
            (!provisioned_only || is_provisioned_rid(rid))) {
            *region_name = (char *)REGION_NAMES[i];
            return TRUE;
        }
    }

    mb_printf("Could not find region ID '%d'\r\n", rid);
    *region_name = "<unknown region>";
    return FALSE;
}


// looks up the rid corresponding to the region name
int region_name_to_rid(char *region_name, char *rid, int provisioned_only) {
    for (int i = 0; i < NUM_REGIONS; i++) {
        if (!strcmp(region_name, REGION_NAMES[i]) &&
            (!provisioned_only || is_provisioned_rid(REGION_IDS[i]))) {
            *rid = REGION_IDS[i];
            return TRUE;
        }
    }

    mb_printf("Could not find region name '%s'\r\n", region_name);
    *rid = -1;
    return FALSE;
}

// handles a request to query song metadata
void query_song() {
    char *name;

    // load song
    load_song_md();

    //TODO For some reason the first time that query is called verify song md hash fails. This causes miPod to pring gibberish
//    if( !verify_song_md_hash()){
//    	mb_printf("Unrecognized Song File /n/r");
//    	return;
//    }
//
//    if( !verify_song_md_hash_signature()){
//    	mb_printf("Song File could not be verified /n/r");
//    	return;
//    }
    memset((void *)&c->query, 0, sizeof(query));

    int enabled_region_bits = s.song_md.enabled_regions.regions;
    int region_count = 0;
    for( int i = 0; i < 32; i++)
    {
    	if (enabled_region_bits & 1){
    		rid_to_region_name(i, &name, FALSE);
    		strcpy((char *)q_region_lookup(c->query, region_count), name);
    		region_count += 1;
    	}
    	enabled_region_bits >>= 1;
    }

    c->query.num_regions = region_count;


    // copy owner name
    uid_to_username(s.song_md.owner_id, &name, FALSE);
    strcpy((char *)c->query.owner, name);


    uint64_t enabled_user_bits = s.song_shared_user_md.enabled_users;
    mb_printf("enabled users %d \n\r", enabled_user_bits);
    int user_count = 1;
	for( int i = 0; i < 63; i++)
	{
		if (enabled_user_bits & 1){
			uid_to_username(i, &name, FALSE);
			strcpy((char *)q_user_lookup(c->query, i), name);
			user_count += 1;
		}
		enabled_user_bits >>= 1;
	}
	c->query.num_users = user_count; //TODO Test implement sharing

   mb_printf("Queried song (%d regions, %d users)\r\n", c->query.num_regions, c->query.num_users);
}

void play_song() {
    u32 counter = 0, rem, cp_num, cp_xfil_cnt, offset, dma_cnt, length, *fifo_fill;


    mb_printf("Reading Audio File...");
    load_song_md();
    //print_song_metadata();

    mb_printf("Header = %d", sizeof(header));


    sha256_compute_hash((void*)&s.song_md, sizeof(header)-HASH_SZ-RSA_KEY_SZ, 1, hash_buffer);
    if( !compare_hashes(hash_buffer, s.song_md.header_hash)){
    	mb_printf("Unrecognized Song File \n\r");
    	return;
    }


    mb_printf("Verifying header signature \n\r");
    if( !verify_song_md_hash_signature()){ //This operation uses the Universal Buffer
    	mb_printf("Song File could not be verified \n\r");
    	return;
    }

    // get WAV length
    length = s.song_md.song_size;
    mb_printf("Song length = %d", length);

    //Verify song_verify_hash TODO move to later in the pipeline for increased speed
    mb_printf("Verify song integrity \n\r");
    while(c->song_length == 0){} //Wait for Zynq to process hash

    int plus_one = (s.song_md.song_size % CHUNK_SZ) > 0 ? 1:0;
    int chunked_length = (s.song_md.song_size/CHUNK_SZ + plus_one) * sizeof(song_chunk);
    if(compare_hashes( (void*)s.song_md.song_verify_hash, (void*)c->song_verify_hash) && (c->song_length==chunked_length)){
    	mb_printf("Song hash computed correctly \n\r");
    }else{
    	mb_printf("Song hash mismatch. Song file is corrupted \n\r");
    	return;
    }


    struct AES_ctx ctx;

    // truncate song if locked
    int is_truncated = 1;

    if (length > PREVIEW_SZ && is_locked()) {
        //length = PREVIEW_SZ;
        mb_printf("Song is locked.  Playing only %ds = %dB\r\n",
                   PREVIEW_TIME_SEC, PREVIEW_SZ);
    } else {
        mb_printf("Song is unlocked. Playing full song\r\n");
        //Compute song key by concating user key and common key. Then hashing
        memcpy(universal_buffer, user_key_block, HASH_SZ);
        memcpy(universal_buffer+HASH_SZ, region_key_block, HASH_SZ);
        sha256_compute_hash((void*)universal_buffer , HASH_SZ*2 , 1, hash_buffer); // The first 16 bytes are the song key
        AES_init_ctx_iv(&ctx, hash_buffer, iv); //Initialize AES_CBC key
        is_truncated = 0;
    }

    u8 * chunk_pointer = (u8*)(&c->song.block_array);
    song_chunk * current_chunk = (void*)universal_buffer;

    rem = length;
    fifo_fill = (u32 *)XPAR_FIFO_COUNT_AXI_GPIO_0_BASEADDR;

    int chunk_ct = 0;
    int number_of_chunks = length%sizeof(song_chunk)==0 ? length/sizeof(song_chunk) : length/sizeof(song_chunk) + 1;
    int last_chunk_len = length%sizeof(song_chunk); //The amount of samples in the last chunk. So we don't play junk at the end of the song

    mb_printf("Number of chunks %d", number_of_chunks);
    // write entire file to two-block codec fifo
    // writes to one block while the other is being played
    set_playing();
    while(number_of_chunks > chunk_ct) {
        // check for interrupt to stop playback
        while (InterruptProcessed) {
            InterruptProcessed = FALSE;

            switch (c->cmd) {
            case PAUSE:
                mb_printf("Pausing... \r\n");
                set_paused();
                while (!InterruptProcessed) continue; // wait for interrupt
                break;
            case PLAY:
                mb_printf("Resuming... \r\n");
                set_playing();
                break;
            case STOP:
                mb_printf("Stopping playback...");
                return;
            case RESTART:
                mb_printf("Restarting song... \r\n");
                chunk_ct = 0; // reset song counter
                set_playing();
            default:
                break;
            }
        }

        // calculate write size and offset
        cp_num = (rem > CHUNK_SZ) ? CHUNK_SZ : rem;
        offset = (counter++ % 2 == 0) ? 0 : CHUNK_SZ;

        //Load chunk into universal_buffer
        memcpy((void*)current_chunk, (void *)(chunk_pointer),(u32)(sizeof(song_chunk)));
        chunk_pointer += sizeof(song_chunk); //TODO modify for rr and ff



        if(chunk_ct < PREVIEW_CHUNK_CT){
        	//preview chunks
        	//TODO Verify signature (Begin process)
        	rsa_begin_verify( (void*)current_chunk->chunk_hash_signature, (void*)GLOBAL_PUBLIC_E, (void*)GLOBAL_PUBLIC_N); //TODO check

        }else{
        	//encrypted chunks
        	//Decrypt the current chunk
        	if(is_truncated){ //Stop playback if song is truncated
        		return;
        	}
        	AES_CBC_decrypt_buffer(&ctx, (void *)(current_chunk), (u32)sizeof(song_chunk));
        }

        u8 chunk_hash_buffer[HASH_SZ];
        memcpy((void*)chunk_hash_buffer, (void*)current_chunk->chunk_hash, HASH_SZ); //Save the chunk hash
        memcpy((void*)current_chunk->chunk_hash, (void*)s.song_md.song_hash, HASH_SZ); //Insert the song hash into the chunk hash space
        //Compute HASH
		sha256_compute_hash((void*)current_chunk , sizeof(song_chunk)-RSA_KEY_SZ , 1, hash_buffer); //Leave out signature during hash computation
		//Verify hash
		if( !compare_hashes((void*)chunk_hash_buffer, (void*)hash_buffer) )
		{
			mb_printf("Song data has been corrupted. Stopping \n\r");
			return;
		}
        //Check that chunk_ct matches
    	if(current_chunk->chunk_number != chunk_ct){
    		mb_printf("Error: song chunk out of order. Stopping \n\r");
    		return;
    	}else{
    		mb_printf("Playing %d \r\n", current_chunk->chunk_number);
    	}



		if( chunk_ct == number_of_chunks ){
			// If this is the last chunk. Only load valid data
			Xil_MemCpy((void *)(XPAR_MB_DMA_AXI_BRAM_CTRL_0_S_AXI_BASEADDR + offset), (void *)(current_chunk->data),(u32)last_chunk_len);
		}else{
	        // do first mem cpy here into DMA BRAM
			Xil_MemCpy((void *)(XPAR_MB_DMA_AXI_BRAM_CTRL_0_S_AXI_BASEADDR + offset), (void *)(current_chunk->data),(u32)sizeof(song_chunk));
		}



        //TODO DO final checks before playing (Check if signature came back valid)
		if(chunk_ct < PREVIEW_CHUNK_CT){
			if( !verify_song_hash_signature( chunk_hash_buffer ,current_chunk->chunk_hash_signature , (void*)GLOBAL_PUBLIC_E, (void*)GLOBAL_PUBLIC_N)){
				print("Chunk signature verification failed \r\n");
				return;
			}
		}

        cp_xfil_cnt = cp_num;

        while (cp_xfil_cnt > 0) {

            // polling while loop to wait for DMA to be ready
            // DMA must run first for this to yield the proper state
            // rem != length checks for first run
            while (XAxiDma_Busy(&sAxiDma, XAXIDMA_DMA_TO_DEVICE)
                   && rem != length && *fifo_fill < (FIFO_CAP - 32));

            // do DMA
            dma_cnt = (FIFO_CAP - *fifo_fill > cp_xfil_cnt)
                      ? FIFO_CAP - *fifo_fill
                      : cp_xfil_cnt;
            fnAudioPlay(sAxiDma, offset, dma_cnt);
            cp_xfil_cnt -= dma_cnt;
        }

        rem -= cp_num;
        chunk_ct+=1;
    }
}

// add a user to the song's list of users
void share_song() {
    int new_md_len, shift;
    char new_md[256], uid;

    // reject non-owner attempts to share
    load_song_md();

    if (!s.logged_in) {
        mb_printf("No user is logged in. Cannot share song\r\n");
        c->song.song_header.song_size = 0;
        return;
    } else if (is_region_locked()){ // This loads the common key into the region_key_block
        mb_printf("Region locked. Cannot share song\r\n");
        c->song.song_header.song_size = 0;
        return;
    } else if (s.uid != s.song_md.owner_id) {
        mb_printf("User '%s' is not song's owner. Cannot share song\r\n", s.username);
        c->song.song_header.song_size = 0;
        return;
    } else if (!username_to_uid((char *)c->username, &uid, TRUE)) {
        mb_printf("Username not found\r\n");
        c->song.song_header.song_size = 0;
        return;
    }



    // generate new song metadata
    uint64_t shared_mask = 1 << uid;

    mb_printf("Generating song key \n\r");
    //Generate song key
    memcpy(universal_buffer, user_key_block, HASH_SZ);
	memcpy(universal_buffer+HASH_SZ, region_key_block, HASH_SZ);
	sha256_compute_hash((void*)universal_buffer , HASH_SZ*2 , 1, hash_buffer); // The first 16 bytes are the song key

	//TODO Get new users public key
	uint8_t * new_use_public_key = (void*)PROVISIONED_USER_PUBLIC_KEY_N_BLOCKS[uid];

    //TODO Encrypt song key using new users public key

	//TODO Write the encrypted song key into the correct shared user key block

	//Update shared users
	mb_printf("Writing enabled_users %d \n\r", shared_mask);
	c->song.shared_user_block.enabled_users |= shared_mask;
	mb_printf("New enabled_users %d \n\r", c->song.shared_user_block.enabled_users);
	c->song.song_header.song_size = s.song_md.song_size; //Write song size to confirm sharing. Even though it doesn't change

    mb_printf("Shared song with '%s'\r\n", c->username);
}

//////////////////////// MAIN ////////////////////////


int main() {
    u32 status;

    init_platform();
    microblaze_register_handler((XInterruptHandler)myISR, (void *)0);
    microblaze_enable_interrupts();

    // Initialize the interrupt controller driver so that it is ready to use.
    status = XIntc_Initialize(&InterruptController, XPAR_INTC_0_DEVICE_ID);
    if (status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    // Set up the Interrupt System.
    status = SetUpInterruptSystem(&InterruptController, (XInterruptHandler)myISR);
    if (status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    // Congigure the DMA
    status = fnConfigDma(&sAxiDma);
    if(status != XST_SUCCESS) {
        mb_printf("DMA configuration ERROR\r\n");
        return XST_FAILURE;
    }

    // Start the LED
    //enableLED(led);
    set_stopped();

    // clear command channel
    memset((void*)c, 0, sizeof(cmd_channel));

    mb_printf("Audio DRM Module has Booted\n\r");

    // Handle commands forever
    while(1) {
        // wait for interrupt to start
        if (InterruptProcessed) {
            InterruptProcessed = FALSE;
            set_working();

            // c->cmd is set by the miPod player
            switch (c->cmd) {
            case LOGIN:
                login();
                break;
            case LOGOUT:
                logout();
                break;
            case QUERY_PLAYER:
                query_player();
                break;
            case QUERY_SONG:
                query_song();
                break;
            case SHARE:
                share_song();
                break;
            case PLAY:
                play_song();
                mb_printf("Done Playing Song\r\n");
                break;
            case DIGITAL_OUT:
                //digital_out();
                break;
            default:
                break;
            }

            // reset statuses and sleep to allowe player to recognize WORKING state
            strcpy((char *)c->username, s.username);
            c->login_status = s.logged_in;
            usleep(500);
            set_stopped();
        }
    }

    cleanup_platform();
    return 0;
}



/*
void sub(uint8_t * A, uint8_t * B, uint8_t * out)
{
	u16 carry = 1;
	for( int i = 127; i >= 0; i--){
		u16 a = A[i];
		u16 b = B[i];
		carry = a + ~b + carry;
		out[i] = carry % 0x100;
		carry >>= 8;
		carry = (carry % 2) ^ 1;
	}
}*/

/*
int main(void)
{
	u32 status;
    init_platform();
	microblaze_register_handler((XInterruptHandler)myISR, (void *)0);
	microblaze_enable_interrupts();

	// Initialize the interrupt controller driver so that it is ready to use.
	status = XIntc_Initialize(&InterruptController, XPAR_INTC_0_DEVICE_ID);
	if (status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Set up the Interrupt System.
	status = SetUpInterruptSystem(&InterruptController, (XInterruptHandler)myISR);
	if (status != XST_SUCCESS) {
		return XST_FAILURE;
	}
	//enableLED(led);
	printf("Starting RSA test \r\n");

//	uint8_t n[] =   {0xa9, 0xd4, 0x30, 0xa7, 0x37, 0x4b, 0xff, 0x93, 0x78, 0xe0, 0x6e, 0xa2, 0x4e, 0x7e, 0x51, 0xa3, 0xe0, 0xdd, 0x46, 0x0a, 0x64, 0x0e, 0xcf, 0xbf, 0x9e, 0x16, 0x2b, 0x35, 0x32, 0x65, 0xf9, 0x24, 0x0a, 0x8f, 0x9b, 0xf6, 0xb9, 0x46, 0x0d, 0xaa, 0xb3, 0x6d, 0x5a, 0x36, 0xd1, 0xdf, 0x27, 0x1c, 0x2d, 0x36, 0xd7, 0xf2, 0xd0, 0x50, 0x9d, 0x8b, 0x94, 0xa9, 0x4c, 0x68, 0x19, 0xb5, 0x8c, 0x9a, 0x87, 0xc6, 0x8d, 0xb4, 0x67, 0xa0, 0x4c, 0x64, 0x11, 0x8a, 0xb0, 0x4a, 0xbf, 0xd7, 0x1b, 0x79, 0x5c, 0x7a, 0x06, 0x01, 0x14, 0x06, 0xbf, 0xfb, 0xb1, 0xa9, 0xdc, 0x0d, 0x43, 0xdb, 0x7a, 0x84, 0x40, 0xb6, 0xa3, 0x62, 0x65, 0xd8, 0xec, 0x56, 0x16, 0x6a, 0x70, 0xf6, 0x63, 0xcd, 0xa4, 0xe9, 0x17, 0xea, 0x2a, 0xd5, 0xad, 0x7e, 0x53, 0x78, 0xcb, 0x5d, 0xbc, 0x3b, 0xcb, 0xf7, 0x9b, 0x05 };
//
//	uint8_t e[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01 };
//
//	uint8_t d[] =   {0x71, 0xf0, 0x53, 0x88, 0x0c, 0x78, 0x67, 0x8a, 0xc8, 0x61, 0x42, 0xb8, 0x90, 0x12, 0xfd, 0xb1, 0x06, 0x0f, 0x4e, 0x8b, 0x70, 0x1f, 0xe3, 0xcf, 0xba, 0x3f, 0x43, 0x53, 0xd8, 0x71, 0x43, 0xda, 0xa3, 0x5f, 0x40, 0x13, 0x22, 0xb0, 0x56, 0x40, 0xfd, 0x4a, 0x53, 0x69, 0x4e, 0x1a, 0xfa, 0x41, 0x54, 0x30, 0x64, 0x67, 0x9a, 0xcd, 0x4b, 0x35, 0xb7, 0x52, 0x72, 0x59, 0xb1, 0x4d, 0xf5, 0x7b, 0x29, 0x36, 0xaf, 0x2e, 0xf4, 0xca, 0xe4, 0x92, 0x91, 0x03, 0x33, 0x44, 0xec, 0x66, 0xa5, 0x80, 0x8d, 0x03, 0xe3, 0x3c, 0x3b, 0x5d, 0x75, 0xaf, 0x0e, 0x4f, 0x21, 0x13, 0x56, 0x0f, 0xb4, 0x57, 0xf4, 0x0f, 0xd9, 0x70, 0x79, 0x5d, 0x08, 0x69, 0x7a, 0x26, 0xda, 0x80, 0x8d, 0xb6, 0xd9, 0xb8, 0xd6, 0x50, 0xd1, 0x07, 0x37, 0xe8, 0x00, 0xf6, 0x2b, 0xc9, 0x80, 0x77, 0x7c, 0x28, 0x3f, 0xa1 };
//
//	uint8_t msg[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x1c, 0xe8, 0x1d, 0xb1, 0xd7, 0xc2, 0x92, 0x9d, 0x10, 0xf0, 0xde, 0x2f, 0xca, 0x1e, 0xe5, 0xfe, 0xa3, 0x37, 0x4c, 0xd1, 0x71, 0x94, 0x84, 0x1a, 0x36, 0xf5, 0xea, 0x8c, 0xe2, 0x91, 0x84, 0xe7, 0x86, 0xbe, 0x77, 0x1e, 0x55, 0x74, 0x61, 0x90, 0xc3, 0x3a, 0x3d, 0x29, 0x0b, 0xec, 0xcb, 0xec, 0xd6, 0xe4, 0xfc, 0x08, 0xab, 0xac, 0xfe, 0x2c, 0x95, 0x79, 0x35, 0x92, 0x27, 0x62, 0x38 };
//
//	uint8_t sig[] =   {0x8d, 0xd5, 0xa1, 0x86, 0x2d, 0x6c, 0x85, 0xcd, 0xc6, 0xe0, 0xfb, 0x2d, 0x52, 0x49, 0x99, 0x04, 0x43, 0x07, 0x95, 0xb6, 0xfc, 0x82, 0x0e, 0xec, 0x83, 0xc6, 0x67, 0xbd, 0x8b, 0xc5, 0xcd, 0x51, 0x78, 0x37, 0x81, 0xfe, 0xa2, 0xfb, 0x57, 0x33, 0xbc, 0x1e, 0x95, 0xfa, 0x8c, 0x26, 0x79, 0x59, 0xe1, 0xcf, 0x15, 0x75, 0xa0, 0x4a, 0x29, 0x86, 0xc5, 0x26, 0xfe, 0xed, 0x62, 0x95, 0x32, 0x1e, 0xd6, 0xd3, 0x79, 0x72, 0x66, 0x55, 0x09, 0xb0, 0x22, 0x70, 0xbf, 0x34, 0xbb, 0xf0, 0x0c, 0xd0, 0x0f, 0x52, 0x01, 0xc9, 0x4e, 0xf2, 0x3b, 0x89, 0x61, 0x22, 0x8a, 0xce, 0x0f, 0x90, 0x5a, 0xd2, 0xbb, 0x76, 0x63, 0x63, 0x52, 0x8c, 0xee, 0xef, 0x44, 0x79, 0xd7, 0x78, 0xe6, 0x9e, 0xe1, 0xb9, 0xbf, 0x1f, 0x02, 0xf0, 0xd1, 0x19, 0x86, 0x6b, 0x3b, 0xa8, 0x50, 0x72, 0xbb, 0xd3, 0x0d, 0xde };


//	uint8_t n[] =   {0xbd, 0x7e, 0x2e, 0x2c, 0xf3, 0xfe, 0x81, 0x90, 0xff, 0x06, 0xa3, 0x28, 0x64, 0x83, 0x57, 0x27, 0xcf, 0x70, 0x9e, 0x8d, 0xa4, 0x9a, 0x3b, 0xa7, 0x66, 0x84, 0xd8, 0x08, 0xb9, 0x9e, 0xd4, 0x86, 0x6c, 0x06, 0x39, 0x1c, 0xce, 0xae, 0xe0, 0x1b, 0x4a, 0x6b, 0x2e, 0x4e, 0x24, 0x3c, 0x42, 0xef, 0xf4, 0xfc, 0x9d, 0xd4, 0xf2, 0x09, 0xc7, 0x2c, 0x13, 0xa1, 0x39, 0x07, 0x63, 0x9f, 0xe5, 0x93, 0x29, 0x31, 0xe7, 0xe9, 0xcb, 0xc7, 0x77, 0x52, 0xc1, 0xee, 0x74, 0x1b, 0x80, 0xa3, 0x91, 0xbb, 0x1a, 0x5d, 0x51, 0x8d, 0xba, 0x85, 0x38, 0xa7, 0xfe, 0xe3, 0x74, 0x31, 0x1d, 0x52, 0x1d, 0xad, 0x2c, 0x67, 0xc9, 0xab, 0xb5, 0x2d, 0x7d, 0x7f, 0x91, 0x05, 0x58, 0x99, 0x80, 0x12, 0xf4, 0x4a, 0x87, 0x34, 0xb0, 0x59, 0xd0, 0x39, 0x7d, 0x4d, 0x05, 0x9d, 0x6c, 0x7c, 0xd2, 0xf3, 0xa9, 0x41 } ;
//
//	uint8_t e[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01 } ;
//
//	uint8_t d[] =   {0xb4, 0xec, 0x3d, 0xd0, 0x43, 0xe2, 0x32, 0xf9, 0x2a, 0xd5, 0xbe, 0x80, 0x39, 0x7f, 0xc1, 0x7e, 0x4c, 0x2c, 0x5d, 0xe6, 0x25, 0x4b, 0xf1, 0x3b, 0x02, 0xc2, 0x41, 0xb6, 0x0a, 0xec, 0x60, 0x44, 0x3b, 0xed, 0xb1, 0x28, 0x15, 0x1a, 0x98, 0xf4, 0xd5, 0x98, 0x02, 0x2d, 0x2f, 0xa1, 0xad, 0xd3, 0x87, 0xd8, 0x8e, 0x25, 0x9c, 0x36, 0xc3, 0xc9, 0x0c, 0xb0, 0xf9, 0x4f, 0x59, 0xca, 0x78, 0x18, 0xe6, 0x2c, 0xc1, 0x96, 0x43, 0xe1, 0x08, 0xce, 0xe7, 0x24, 0x8d, 0x47, 0x44, 0x5e, 0x13, 0xe2, 0xb7, 0xd0, 0x7d, 0x5a, 0x22, 0xea, 0x44, 0x57, 0x9f, 0xc7, 0xd0, 0xca, 0x1c, 0x55, 0x64, 0x60, 0x1c, 0xa9, 0xd8, 0x56, 0xcf, 0x48, 0xc5, 0x60, 0x02, 0x43, 0xcf, 0x8e, 0x45, 0x17, 0xb7, 0x0b, 0x2b, 0xfe, 0xa0, 0x35, 0x6e, 0x03, 0x56, 0x3b, 0x9d, 0xa1, 0xd5, 0x3d, 0xb8, 0xae, 0x27, 0x01 } ;
//
//	uint8_t msg[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x1c, 0xe8, 0x1d, 0xb1, 0xd7, 0xc2, 0x92, 0x9d, 0x10, 0xf0, 0xde, 0x2f, 0xca, 0x1e, 0xe5, 0xfe, 0xa3, 0x37, 0x4c, 0xd1, 0x71, 0x94, 0x84, 0x1a, 0x36, 0xf5, 0xea, 0x8c, 0xe2, 0x91, 0x84, 0xe7, 0x86, 0xbe, 0x77, 0x1e, 0x55, 0x74, 0x61, 0x90, 0xc3, 0x3a, 0x3d, 0x29, 0x0b, 0xec, 0xcb, 0xec, 0xd6, 0xe4, 0xfc, 0x08, 0xab, 0xac, 0xfe, 0x2c, 0x95, 0x79, 0x35, 0x92, 0x27, 0x62, 0x38 } ;
//
//	uint8_t sig[] =   {0x30, 0x92, 0x85, 0x53, 0xad, 0xaa, 0x0e, 0xe6, 0x0d, 0x78, 0xff, 0xac, 0xf0, 0x79, 0x3a, 0xa4, 0xda, 0x4f, 0x89, 0x68, 0x77, 0xcd, 0x86, 0x92, 0xea, 0x9f, 0xdb, 0xa4, 0x88, 0x38, 0x59, 0xcf, 0x61, 0x2d, 0x60, 0xe6, 0xd2, 0x8e, 0x62, 0xe2, 0xff, 0xfa, 0x9c, 0xfb, 0x09, 0x31, 0xb6, 0x42, 0x9c, 0x9d, 0x06, 0xa5, 0x31, 0x6f, 0x19, 0x7d, 0x9f, 0x5d, 0xc8, 0xfd, 0xd0, 0xa7, 0x09, 0x01, 0xb5, 0xea, 0x25, 0x9f, 0x29, 0x08, 0x18, 0x20, 0x10, 0xe7, 0x39, 0x2d, 0xdd, 0x5a, 0x1a, 0x43, 0xf0, 0x10, 0x04, 0x8d, 0x8b, 0xc6, 0x39, 0x32, 0xc2, 0x65, 0x71, 0xf3, 0x2b, 0x2c, 0x97, 0x6c, 0x67, 0xf3, 0x34, 0x3c, 0x01, 0xc2, 0x8e, 0x20, 0x20, 0x8f, 0xf1, 0x65, 0xdb, 0xf2, 0x14, 0x06, 0x9b, 0x30, 0xa1, 0xc4, 0x5b, 0x48, 0x70, 0x84, 0xa9, 0xc4, 0x0f, 0x81, 0x80, 0x3d, 0x99, 0xfe } ;


//	uint8_t msg[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B } ;
//
//	uint8_t d[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32 } ;
//
//	uint8_t n[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C } ;
//
//	uint8_t sig[] =   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A } ;


//	uint8_t e[] =   {0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;
//
//	uint8_t d[] =   {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;
//
//	uint8_t n[] =   {0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;
//
//	uint8_t sig[] =   {0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;

	uint8_t out[128] = {0};
	uint8_t fout[128] = {0};

	uint8_t sig[] =   {0x55, 0x27, 0x73, 0x0f, 0x98, 0x03, 0xff, 0x41, 0x73, 0x90, 0x51, 0xae, 0xfb, 0x47, 0x58, 0x3b, 0xc8, 0x02, 0xaa, 0x78, 0x16, 0x3d, 0xa1, 0xa1, 0x7f, 0x9e, 0x9c, 0x3b, 0x61, 0x42, 0xe4, 0xcd, 0x66, 0x29, 0xfd, 0xf1, 0x4a, 0xdb, 0x18, 0x55, 0x64, 0x0b, 0xa0, 0x98, 0x01, 0x2d, 0x94, 0xf2, 0x2c, 0x34, 0xf8, 0x59, 0x00, 0x2f, 0x68, 0xe2, 0xd2, 0xd5, 0x69, 0x47, 0xe7, 0x54, 0x58, 0xc8, 0xe5, 0x8a, 0x43, 0xe7, 0x00, 0x05, 0xbd, 0x2f, 0xc9, 0xfd, 0x8e, 0x99, 0xe8, 0xe2, 0x9e, 0xc4, 0x4c, 0x09, 0xc4, 0xd0, 0xc7, 0x87, 0x72, 0x5c, 0x1c, 0x29, 0x6e, 0x6c, 0xd1, 0x19, 0x31, 0xa8, 0x01, 0xe8, 0xa7, 0xdb, 0x4a, 0xd7, 0x70, 0x72, 0x41, 0x12, 0x68, 0x6b, 0xa5, 0x9a, 0x94, 0x3f, 0x80, 0x8d, 0x84, 0xc7, 0x47, 0xf8, 0x7c, 0x9c, 0xa6, 0x75, 0xe7, 0xf6, 0x58, 0x5b, 0x60, 0x6c };


	// Create signature
//	rsa_encrypt( msg, d, n,  out);
//
//    if (0 == memcmp((char*) out, (char*) sig, 128)) {
//    	set_playing();
//    	printf("Test Passed Sign\n\r");
//
//    } else {
//    	set_paused();
//    	printf("Test Failed Sign\n\r");
//		printf("msg d n out \n\r");
//		for (int i = 0; i < 128; i++)
//		{
//			printf("%02x %02x %02x %02x\n\r", msg[i], d[i], n[i], out[i]);
//		}
//    }

    // Verify signature
	rsa_encrypt( sig, GLOBAL_PUBLIC_E, GLOBAL_PUBLIC_N,  out);

	sub(out, GLOBAL_PUBLIC_N, fout);

	for (int i = 0; i < 128; i++)
	{
		printf("%02x %02x %02x \n\r", out[i], fout[i], GLOBAL_PUBLIC_N[i]);
	}

//	if (0 == memcmp((char*) out, (char*) msg, 128)) {
//		set_playing();
//		printf("Testy Passed \n\r");
//
//	} else {
//		set_paused();
//		printf("Test Failed \n\r");
//	}



    while(1){

    }
    cleanup_platform();
    return 0;
}
*/

